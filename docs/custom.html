<h1>Custom Components</h1>
<p class="center">
  A component is a self-contained set of styles, behaviors and layout.
  It can be as simple to use as an html tag. A component hides complexity
  and adds usefulness. It should do one thing in a generalized way that
  makes it reusable.
</p>
<pre><code>
class ChildComponent extends Tonic {
  <i>//
  // A constructor is not required.
  //</i>
  constructor (props) {
    super(props)

    <i>//
    // CSS can be be read-in from a separate file, compiled by a
    // or you can use your fav CSS-in-JS solution. Either way,
    // your style will be "private" and won't affect any other part
    // of the page. No prefix hacks or monkey patching needed.
    //</i>
    this.stylesheet = `
      div {
        display: inline-block;
        border: 1px dotted #666;
        height: 100px;
        width: 100px;
        line-height: 90px;
      }
    `
  }

  <i>//
  // You can listen to any dom event by creating a method with
  // the corresponding name. The method will receive the plain
  // old Javascript event object.
  //</i>
  mouseover (e) {
    e.target.style.backgroundColor = someRandomColor
  }

  <i>//
  // The <b>root dom node</b> of the component can be accessed
  // from <b>this.root</b> or <b>this.shadowRoot</b> if you have added
  // a shadow dom to your component.
  //</i>
  mouseout (e) {
    const div = this.shadowRoot.querySelector('div')
    div.style.backgroundColor = '#fff'
  }

  <i>//
  // The render function should return a string. It's a plain
  // old string, so it can be composed any way you want.
  //</i>
  render () {
    return `
      &lt;div class="child"&gt;
        Child ${this.props.value}
      &lt;/div&gt;
    `
  }
}

</code>
</pre>

        <p class="center">
          A <b>parent</b> component that uses the <b>child</b> component.
        </p>
        <pre><code>
class ParentComponent extends Tonic {
  <i>//
  // The <b>connected</b> event is fired once the root element is
  // attached to the dom. You can also use any of the web
  // component lifecycle events.
  //</i>
  connected (el) {
    console.log('Mounted! The dom node is ready to use.')
  }

  getRandomValue () {
    return Math.random().toString(16).slice(2, 8)
  }

  click (e) {
    <i>//
    // Often you'll want to check <b>what</b> element in the component
    // was clicked. Try <b><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/matches">Element.matches()</a></b>, <b><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/closest">Element.closest()</a></b>,
    // and <b>Tonic.match()</b> (try to match the given selector or find
    // the closest match).
    //</i>
    if (!e.target.matches('.parent')) return
    <i>//
    // Set state on a component instance or on this instance,
    // <b>setProps()</b> will cause a downward cascade of re-rendering.
    // Set props can also accept a function that will provide
    // the current props as an argument.
    //</i>
    this.setProps({ value: this.getRandomValue() })
  }

  <i>//
  // <b>this.html</b> template tag makes it easy to escape values.
  // You can also return another node, for example a <b>&lt;template&gt;</b>
  // tag.
  //</i>
  render () {
    return this.html`
      &lt;div class=&quot;parent&quot;&gt;
        Parent
        &lt;child-component value=${this.props.value}&gt;
        &lt;/child-component&gt;
      &lt;/div&gt;
    `
  }
}</code>

</pre>

        <p class="center">Register your components to use them anywhere.</p>
        <pre><code>
<i>//
// Register your components before using them. If you specify the
// "shadow" option, your components will render into a shadow dom.
//</i>
Tonic.add(ChildComponent, { shadow: true })
Tonic.add(ParentComponent)
</code>
</pre>

        <p class="center">Add components to your html, pass them data.</p>
<pre><code>
<i>//
// Web components can not be "self-closing". They also must
// be two or more words. For example, <b>ParentComponent</b>
// instead of <b>Parent</b>.
//</i>
const someNode = document.querySelector('#demo')

someNode.innerHTML = `
  &lt;parent-component value="7a"&gt;
  &lt;/parent-component&gt;
`

<i>//
// Native HTML only understands strings. If you want to pass
// non-string props, from the HTML you need to first stringify
// them. The "data" attribute is special and will automatically
// be parsed into json for you. Don't forget single quotes!
//</i>
`&lt;parent-component id="parent" data='${JSON.stringify(data)}'&gt;
&lt;/parent-component&gt;`

<i>//
// Alternatively, you can call the method on the element.
//</i>
document.getElementById('parent').setProps(data)
</code>
</pre>

        <p class="center">Demo (click and hover).</p>
        <div id="demo"></div>

        <p class="center">
          Prerendering and returning dom nodes from the render function.
        </p>
<pre><code>
class AnotherThing extends Tonic {
  constructor () {
    super()

    <i>//
    // If you have lots of structure, but only a few
    // changes, you could prerender your layout to create
    // a reusable node and pass it to the <b>render</b> method.
    // This structure could also come from a &lt;template&gt;
    // tag which would also improve performance.
    //</i>
    this.template = document.createElement('div')
  }

  connected () {
    <i>//
    // Target and update a few nodes directly.
    //</i>
  }

  <i>//
  // Render will automatically deep-clone this node for you.
  //</i>
  render () {
    return this.template
  }
}</code>

</pre>

<p class="center">More details on <a href="https://github.com/hxoht/tonic">Github</a></p>
