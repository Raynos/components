<h1>Custom Components</h1>

<p>Building a component starts with creating a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">Javascript Class</a>.
The class should have at least one method named <b>render</b>
which usually returns a string of html.
</p>
<pre><code>class ExampleComponent extends Tonic {
  render () {
    return `&lt;div&gt;Hello, World.&lt;/div&gt;`
  }
}</code>
</pre>

<p>Next, you can tell the browser about your new class and it will
create a custom html tag for it.</p>
<pre><code>Tonic.add(ExampleComponent)</code>
</pre>

<p>Add your Javascript to your html and now you can now
use your new component anywhere in your html.</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;script src="index.js"&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;example-component&gt;&lt;/example-component&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
</pre>

<p>The result, when rendered by the browser, will be that the html
from your render function will be inserted into the component. As you
can see, the potential complexity of your code will be hidden from the
programmer using it, making their reality a little simpler.</b>

<pre><code>&lt;html&gt;
  &lt;head&gt;
  &lt;script src="index.js"&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;example-component&gt;
      &lt;div&gt;Hello, World.&lt;/div&gt;
    &lt;/example-component&gt;
  &lt;/body&gt;
&lt;/html&gt;</code>
</pre>

<p>Here is a more complex example that demonstrates some more features
and some explaination of what they are and how they work.</p>

<pre><code>class ChildComponent extends Tonic {
  <i>//
  // A <b>constructor</b> (not required) is a class method that will be
  // called once when an instance of your component is created.
  //</i>
  constructor (props) {
    super(props)

    <i>//
    // You can create a "private" stylesheet that will not affect any
    // other part of the page. Since we are using <b>Web Components</b>,
    // this doesn't require any hacks &mdash; hacks that can make debugging
    // much more difficult.
    //</i>
    this.stylesheet = `
      div {
        display: inline-block;
        border: 1px dotted #666;
        height: 100px;
        width: 100px;
        line-height: 90px;
      }
    `
  }

  <i>//
  // You can listen to any dom event that happens in your component
  // by creating a method with the corresponding name. The method will
  // receive the plain old Javascript event object.
  //</i>
  mouseover (e) {
    e.target.style.backgroundColor = someRandomColor
  }

  <i>//
  // The <b>root dom node</b> of the component can be accessed
  // from <b>this.root</b> or <b>this.shadowRoot</b> if you have added
  // a shadow dom to your component.
  //</i>
  mouseout (e) {
    const div = this.shadowRoot.querySelector('div')
    div.style.backgroundColor = '#fff'
  }

  <i>//
  // The render function should return a string. It's a plain
  // old string, so it can be composed any way you want.
  //</i>
  render () {
    return `
      &lt;div class="child"&gt;
        Child ${this.props.value}
      &lt;/div&gt;
    `
  }
}

</code>
</pre>

        <p class="center">
          A <b>parent</b> component that uses the <b>child</b> component.
        </p>
        <pre><code>
class ParentComponent extends Tonic {
  <i>//
  // The <b>connected</b> event is fired once the root element is
  // attached to the dom. You can also use any of the web
  // component lifecycle events.
  //</i>
  connected (el) {
    console.log('Mounted! The dom node is ready to use.')
  }

  getRandomValue () {
    return Math.random().toString(16).slice(2, 8)
  }

  click (e) {
    <i>//
    // Often you'll want to check <b>what</b> element in the component
    // was clicked. Try <b><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/matches">Element.matches()</a></b>, <b><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/closest">Element.closest()</a></b>,
    // and <b>Tonic.match()</b> (try to match the given selector or find
    // the closest match).
    //</i>
    if (!e.target.matches('.parent')) return
    <i>//
    // Set state on a component instance or on this instance,
    // <b>setProps()</b> will cause a downward cascade of re-rendering.
    // Set props can also accept a function that will provide
    // the current props as an argument.
    //</i>
    this.setProps({ value: this.getRandomValue() })
  }

  <i>//
  // <b>this.html</b> template tag makes it easy to escape values.
  // You can also return another node, for example a <b>&lt;template&gt;</b>
  // tag.
  //</i>
  render () {
    return this.html`
      &lt;div class=&quot;parent&quot;&gt;
        Parent
        &lt;child-component value=${this.props.value}&gt;
        &lt;/child-component&gt;
      &lt;/div&gt;
    `
  }
}</code>

</pre>

        <p class="center">Register your components to use them anywhere.</p>
        <pre><code>
<i>//
// Register your components before using them. If you specify the
// "shadow" option, your components will render into a shadow dom.
//</i>
Tonic.add(ChildComponent, { shadow: true })
Tonic.add(ParentComponent)
</code>
</pre>

        <p class="center">Add components to your html, pass them data.</p>
<pre><code>
<i>//
// Web components can not be "self-closing". They also must
// be two or more words. For example, <b>ParentComponent</b>
// instead of <b>Parent</b>.
//</i>
const someNode = document.querySelector('#demo')

someNode.innerHTML = `
  &lt;parent-component value="7a"&gt;
  &lt;/parent-component&gt;
`

<i>//
// Native HTML only understands strings. If you want to pass
// non-string props, from the HTML you need to first stringify
// them. The "data" attribute is special and will automatically
// be parsed into json for you. Don't forget single quotes!
//</i>
`&lt;parent-component id="parent" data='${JSON.stringify(data)}'&gt;
&lt;/parent-component&gt;`

<i>//
// Alternatively, you can call the method on the element.
//</i>
document.getElementById('parent').setProps(data)
</code>
</pre>

        <p class="center">Demo (click and hover).</p>
        <div id="demo"></div>

        <p class="center">
          Prerendering and returning dom nodes from the render function.
        </p>
<pre><code>
class AnotherThing extends Tonic {
  constructor () {
    super()

    <i>//
    // If you have lots of structure, but only a few
    // changes, you could prerender your layout to create
    // a reusable node and pass it to the <b>render</b> method.
    // This structure could also come from a &lt;template&gt;
    // tag which would also improve performance.
    //</i>
    this.template = document.createElement('div')
  }

  connected () {
    <i>//
    // Target and update a few nodes directly.
    //</i>
  }

  <i>//
  // Render will automatically deep-clone this node for you.
  //</i>
  render () {
    return this.template
  }
}</code>

</pre>

<p class="center">More details on <a href="https://github.com/hxoht/tonic">Github</a></p>
